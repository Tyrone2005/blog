<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hello,Hexo</title>
    <url>/2021/03/26/helloHexo/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Testing</tag>
        <tag>Another Tag</tag>
      </tags>
  </entry>
  <entry>
    <title>深入学习JVM</title>
    <url>/2021/04/08/jvm/</url>
    <content><![CDATA[<p>​        学习JVM，可以从三个部分理解JVM：JVM类加载机制、JVM运行时数据区、执行引擎；</p>
<p>​        <span id="more"></span></p>
<p>​          <img src="/2021/04/08/jvm/JVM1.jpg"></p>
<h2 id="一-JVM的类加载机制"><a href="#一-JVM的类加载机制" class="headerlink" title="(一) JVM的类加载机制"></a><strong>(一) JVM的类加载机制</strong></h2><p>​        java文件在经过编译后，生成的class文件通过类加载器加载到JVM中，然后验证加载的类是否为符合JVM规范的字节码文件，然后给类的静态变量分配内存，并赋予默认值，再经过解析、初始化工作，此时可以正常使用对应的类了。</p>
<p>​          主要过程有如下：</p>
<p>​            <strong>加载</strong>—&gt;<strong>验证</strong>—&gt;<strong>准备</strong>—&gt;<strong>解析</strong>—&gt;<strong>初始化</strong>—&gt;<strong>使用</strong>—&gt;<strong>卸载</strong></p>
<p>​           加载：在使用到某个类的时候，类加载器会通过IO将硬盘上的class文件加载到内存中，并生成一个代表此类的java.lang.Class对象，作为运行时数据区中的方法区这个类的各种数据的访问入口。</p>
<p>​            类加载器分为引导类加载器、扩展类加载器、应用程序类加载器、自定义类加载器。引导类加载器（bootstrapLoader）负责加载支撑JVM运行的核心类库，即位于JRE的lib目录下的类库，比如rt.jar等；扩展类加载器（extClassloader）负责加载支撑JVM运行的JRE的lib目录下的ext扩展目录下的jar;应用程序类加载器（appClassLoader）负责加载ClassPath下的jar,主要是加载开发者开发的类；自定义加载器负责加载用户自定义路径下的类包；</p>
<p>​            双亲委派机制：所谓类加载器的双亲委派模型指的是类加载器之间的层次关系。该模型要求除了顶层的引导类加载器外，其余的类加载器都应该有自己的父类加载器，而这种父子关系一般是通过组合的关系来实现，而不是通过继承。        </p>
<p>​    <img src="/2021/04/08/jvm/JVM3.jpg"></p>
<p>​           当一个类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器找到了目标类，则成功返回；若父类加载失败，则抛出ClassNotFoundException异常后，再调用自己的findClass（）方法进行加载，依次类推，直到加载成功或者返回null,若应用程序类加载器加载成功，下次再使用到该类的时候，就直接从自己的类库中加载该类。</p>
<p>以下为java.lang.ClassLoader加载类的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下边这张图来更直观的描述一下上面这段代码的流程：</p>
<p><img src="/2021/04/08/jvm/JVM4.jpg"></p>
<p>​            <strong>双亲委派机制存在意义如何？</strong>试想一下，如果开发者编写了一个与核心类库同名的类，如果没有双亲委派机制，在使用到该类的时候，应用程序类加载器会直接加载自己编写的类，会造成怎样的安全隐患。再者，如果使用到核心类库，引导类加载器加载了一次，如果扩展类也用到了该类，也加载了一次，如果应用程序类也用到了该类，还得再加载一次，那么系统中会有多个相同的类，类的唯一性无法确保，这就给JVM造成了不必要的负担。因此<strong>双亲委派机制的存在意义为：安全和防止类重复加载</strong>；</p>
<p>​            <strong>如何打破双亲委派机制？</strong> 双亲委派模型并非强制性约束，而是Java设计者推荐给开发者的类加载实现方式，在Java中大部分的类加载器都遵循这个模型，但也有类外。</p>
<blockquote>
<p><em>原生的JDBC中Driver驱动本身只是一个接口，并没有具体的实现，具体的实现是由不同数据库类型去实现的。例如，MySQL的mysql-connector-.jar中的Driver类具体实现的。 原生的JDBC中的类是放在rt.jar包的，是由启动类加载器进行类加载的，在JDBC中的Driver类中需要动态去加载不同数据库类型的Driver类，而mysql-connector-.jar中的Driver类是用户自己写的代码，那启动类加载器肯定是不能进行加载的，既然是自己编写的代码，那就需要由应用程序启动类去进行类加载。于是乎，这个时候就引入线程上下文件类加载器(Thread Context ClassLoader)。有了这个东西之后，程序就可以把原本需要由启动类加载器进行加载的类，由应用程序类加载器去进行加载了。</em></p>
</blockquote>
<p>​        <strong>若要打破双亲委派机制，需要继承ClassLoader类，重写loadClass（）方法。</strong></p>
<h2 id="（二）垃圾回收"><a href="#（二）垃圾回收" class="headerlink" title="（二）垃圾回收"></a><strong>（二）垃圾回收</strong></h2><p>​           </p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Tyrone</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之23种设计模式(单例模式)</title>
    <url>/2021/04/01/singelton/</url>
    <content><![CDATA[<p><strong>单例模式是23种设计模式中最常用的一种，属于对象创建型模式；</strong></p>
<p><strong>核心思想：</strong></p>
<p>​    保证系统中一个类仅有一个实例，并且提供一个访问该实例的全局访问方法。</p>
<span id="more"></span>

<p><strong>单例模式特点：</strong></p>
<p>1.单例类只能 有一个实例；</p>
<p>2.单例类必须自己创建唯一实例</p>
<p>3.单例类必须给其他对象提供访问该实例的方法；</p>
<p><strong>常见的应用场景：</strong>Windows任务管理器，数据库连接池，Java中的Runtime，spring中Bean的默认生命周期;</p>
<p><strong>单例模式的优点：</strong></p>
<p>1.提供了唯一实例的全局访问方法，可以优化共享资源的访问</p>
<p>2.避免对象的频繁创建和销毁，可以提高性能。</p>
<p>实现方法一：<strong>饿汉式单例实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> singleton;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式单例实现<strong>优点</strong>：</p>
<p>​        由于在类加载的时候，已经实例化了实例，因此在后续getInstance（）访问性能较高高；另外在多线程环境中，java能保证在加载时，总是以单线程实例化，所以是线程安全的。</p>
<p><strong>缺点</strong>也很明显，在每次类加载的时候，都会进行实例化，特别是对象较大的时候，会造成大量资源浪费；</p>
<p>实现方式二：<strong>懒汉式单例实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> singleton;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式单例实现<strong>优点</strong>：</p>
<p>​    访问getInstance（）性能高，延迟初始化，避免资源浪费；</p>
<p><strong>缺点</strong>：</p>
<p>在多线程环境下，可能出现多个实例，因此是非线程安全的；</p>
<p>​        既然懒汉式单例实现方式非线程安全，那可不可以使用synchronized 关键字来实现线程安全的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span>   Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> singleton;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        如果在多线程的环境下，因为单例模式共享资源的特性，多个线程需要使用，必然会出现阻塞的情况，大量线程等待一个线程使用完了之后才能使用该单例，性能必然受到影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    使用同步块，解决了性能的问题，但是是线程安全的吗？非线程安全的！因为在new的时候，虚拟机内部的操作是通过多个步骤来实现的，在JVM内部可能会发生<strong>指令重排</strong>，会导致获取的实例是非正常的实例，或许没有进行初始化，因此，这种方式也不可取。</p>
<p>​    <img src="/2021/04/01/singelton/initObj.jpg"></p>
<p>这个时候，想到了volatile,它可以防止指令重排，到此，一个完整的单例模式已经完成。</p>
<p>​    其实还有几种单例模式的实现方式，实现起来比较优雅，比如利用内部类的特性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> Holder.singleton;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Tyrone</tag>
      </tags>
  </entry>
</search>
